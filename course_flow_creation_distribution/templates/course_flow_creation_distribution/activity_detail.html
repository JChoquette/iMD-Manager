{% load static i18n %} {% get_current_language as LANGUAGE_CODE %}

<!DOCTYPE html>
<html lang="{{LANGUAGE_CODE}}">
  <head>
    <title>{% block title %}{% endblock %}</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="{% block metadescription %}{% endblock %}"
    />
    <meta name="theme-color" content="#1976BC" />

    <!-- External resources -->
    <!-- * Fonts and icons -->
    <link
      href="https://fonts.googleapis.com/css?family=Material+Icons|Roboto|Fanwood+Text:400i|Quicksand:300,400|Rubik:200,300,300i,400"
      rel="stylesheet"
      type="text/css"
    />

    <!-- * Scripts -->
    <!-- ** Preloads -->
    <link
      rel="preload"
      href="https://cdn.polyfill.io/v2/polyfill.min.js"
      as="script"
    />
    <link rel="preload" href="https://d3js.org/d3.v5.min.js" as="script" />
    <!-- ** jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <!-- ** Polyfills for non-awesome browsers-->
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
    <!-- ** d3 -->
    <script
      src="https://d3js.org/d3.v5.min.js"
      defer="true"
      charset="utf-8"
    ></script>

    <!-- Internal resources -->
    <!-- * CSS -->
    <link
      rel="stylesheet"
      href="{% static 'course_flow_creation_distribution/css/base_style.css' %}"
    />
    <script src=""></script>
  </head>

  <body id="site">
    <svg id="dragdrop" width="1400" height="900"></svg>
    <footer></footer>
  </body>
  {% csrf_token %}
  <script>
        window.addEventListener("load", function() {

          const svg = d3.select("svg").attr("class","activity");

          const objectJson = {{ activity_json|safe }};

          console.log(objectJson);



          const strategyActivitySet = objectJson.strategyactivity_set;

          const nodeHeight = 80.0;
          const nodeWidth = 300.0;
          const nodeSpacingVertial = 30.0;
          const nodeSpacingHorizontal = 30.0;

          let runningActivityHeight = 0;

          function swapDiv(referenceNode){
              referenceNode.parentNode.insertBefore(referenceNode, referenceNode.parentNode.lastChild.nextSibling);
          }

          renderActivity(strategyActivitySet, svg);

          function renderActivity(strategyActivitySet, svg){

              const strategies = svg.selectAll('.strategy').data(strategyActivitySet).enter()
                                .append("svg").attr("class","strategy")
                                .attr("x", "0")
                                .attr("height", (d,i)=>`${d.strategy.nodestrategy_set.length*(nodeHeight+nodeSpacingVertial)-nodeSpacingVertial}`)
                                .each(function(d,i){

                                  d3.select(this).append("rect").attr('x', 0).attr('y', 0).attr("rx", "6")
                                      .attr("width", `${(nodeWidth+nodeSpacingHorizontal)*3-nodeSpacingHorizontal}`)
                                      .attr("height", `${d.strategy.nodestrategy_set.length*(nodeHeight+nodeSpacingVertial)-nodeSpacingVertial}`)
                                      .attr("fill", "yellow").attr("stroke", "black")
                                  renderStrategy(d.strategy.nodestrategy_set, d3.select(this));
                                  d3.select(this).attr("y", `${runningActivityHeight}`)
                                  runningActivityHeight += +d3.select(this).attr("height");

                                });

              function makeDragDropStrategy() {
                let widget = undefined;
                let color = undefined;
                let widgetData = undefined;
                let initYAxis = undefined;

                let drags = d3
                  .drag()
                  .on("start", function() {
                    console.log("dragging");
                    widget = d3.select(this);
                    widgetData = widget.node().__data__;
                    initYAxis = d3.event.y;
                    swapDiv(this);

                  })
                  .on("drag", function() {
                    widget.attr("y", d3.event.y);
                    if(d3.event.y<initYAxis){
                        strategies.each(function(d,i) { if((d.rank == widgetData.rank-1)&&((+d3.select(this).attr("y")+(+d3.select(this).attr("height"))/2)>=+widget.attr("y"))){
                          [d.rank, widgetData.rank] = [widgetData.rank, d.rank];
                          d3.select(this).attr("y",`${+d3.select(this).attr("y")+(+widget.attr("height"))}`);
                        }});
                    }
                    else{
                      strategies.each(function(d,i) { if((d.rank == widgetData.rank+1)&&((+d3.select(this).attr("y")+(+d3.select(this).attr("height"))/2)<=(+widget.attr("y")+(+widget.attr("height"))))){
                        [d.rank, widgetData.rank] = [widgetData.rank, d.rank];
                        d3.select(this).attr("y",`${+d3.select(this).attr("y")-(+widget.attr("height"))}`);
                      }});
                    }
                    initYAxis = d3.event.y;
                  })
                  .on("end", function() {
                    let yRealignPos = 0;
                    strategies.each(function(d,i) {
                        if(d3.select(this).node().__data__.rank<widgetData.rank){
                           yRealignPos += +d3.select(this).attr("height");
                        }
                    });
                    widget.attr("y", `${yRealignPos}`);
                    updateJson();
                    widget = undefined;
                  });

                drags(strategies);
              }

              makeDragDropStrategy();

          }





          function renderNodeLinks(svg, nodeMidpointHorizontal){

              svg.selectAll('line').remove();

              let rects = svg.selectAll('.node')['_groups'][0];

              sortedRects = [rects.length];

              for(let i=0; i<rects.length; i++){
                  for(let j=0; j<rects.length; j++){
                  if(i==rects[j].__data__.rank){
                      sortedRects[i]=rects[j];
                  }
                  else if(rects[j].__data__.rank<0) sortedRects[0]=rects[j];
                  else if(rects[j].__data__.rank>rects.length-1) sortedRects[rects.length-1]=rects[j];
                }
              }


              for(let i=0; i<rects.length-1; i++){
                  svg.append("line")
                      .style("stroke", "black")
                      .attr("x1", nodeMidpointHorizontal + sortedRects[i].x.animVal.value)
                      .attr("y1", nodeHeight + sortedRects[i].y.animVal.value)
                      .attr("x2", nodeMidpointHorizontal + sortedRects[i+1].x.animVal.value)
                      .attr("y2", sortedRects[i+1].y.animVal.value);

              }


          }


          function renderStrategy(nodeStrategySet, svg){


            const scC = d3.scaleOrdinal( d3.schemePastel1 );

            const nodeTotalSpacingVertial = nodeHeight + nodeSpacingVertial;
            const nodeTotalSpacingHorizontal = nodeWidth + nodeSpacingHorizontal;

            const nodeMidpointVertial = nodeHeight/2.0;
            const nodeMidpointHorizontal = nodeWidth/2.0;

            const nodes = svg.selectAll('.node').data(nodeStrategySet).enter()
                              .append("svg").attr("class","node")
                              .attr("x", (d,i) => `${nodeTotalSpacingHorizontal*d.node.classification}`)
                              .attr("y", (d,i) => `${nodeTotalSpacingVertial*d.rank}`);

            nodes.append("rect").attr('x', 0).attr('y', 0).attr("rx", "6")
                .attr("width", `${nodeWidth}`).attr("height", `${nodeHeight}`)
                .attr("fill", (d,i) => scC(i)).attr("stroke", "black");

            nodes
              .append('text')
              .style('font-family', 'Quicksand, sans-serif')
              .attr('class', 'node-label')
              .attr('x', `${nodeMidpointHorizontal}`)
              .attr('y', `${nodeMidpointVertial}`)
              .attr('dy', 6)
              .style('font-size', 14)
              .attr('text-anchor', 'middle')
              .style('fill', 'black')
              .style('pointer-events', 'none')
              .text(d => d.node.title);

            renderNodeLinks(svg, nodeMidpointHorizontal);

              function reorderByRank(previousRank, newRank){
                  nodes.each(function(d,i) { if(d.rank == newRank){
                    d.rank=previousRank;
                    d3.select(this).attr("y",`${d.rank*nodeTotalSpacingVertial}`);
                  }});
              }

          function makeDragDropNode() {
            let widget = undefined;
            let color = undefined;
            let initRank = undefined;
            let currentRank = undefined;
            let initClassification = undefined;
            let currentClassification = undefined;
            let widgetData = undefined;

            let drags = d3
              .drag()
              .on("start", function() {
                widget = d3.select(this);
                color = widget.select("rect").attr("fill");
                widget.select("rect").attr("fill", "lime");
                widgetData = widget.node().__data__;
                initRank = widgetData.rank;
                initClassification = widgetData.node.classification
                swapDiv(this);
              })
              .on("drag", function() {
                widget.attr("x", d3.event.x-nodeMidpointHorizontal).attr("y", d3.event.y-nodeMidpointVertial);
                currentRank = Math.round(widget.attr("y")/nodeTotalSpacingVertial);
                currentClassification = Math.round(widget.attr("x")/nodeTotalSpacingHorizontal);
                if(currentRank != initRank){
                    reorderByRank(initRank, currentRank);
                    widgetData.rank = currentRank;
                    initRank = currentRank;
                }
                if(currentClassification != initClassification){
                    widgetData.node.classification = currentClassification;
                    initClassification = currentClassification;
                }
                renderNodeLinks(svg, nodeMidpointHorizontal);
              })
              .on("end", function() {
                if (widgetData.node.classification < 0) widgetData.node.classification = 0;
                if (widgetData.node.classification > 2) widgetData.node.classification = 2;
                if (widgetData.rank < 0) widgetData.rank = 0;
                if (widgetData.rank > nodeStrategySet.length-1) widgetData.rank = nodeStrategySet.length-1;
                widget.select("rect").attr("fill", color);
                widget.attr("y",(d,i)=>`${d.rank*nodeTotalSpacingVertial}`)
                    .attr("x", (d,i) => `${nodeTotalSpacingHorizontal*d.node.classification}`);
                updateJson();
                renderNodeLinks(svg, nodeMidpointHorizontal);
                widget = undefined;
              });

            drags(nodes);
          }
          makeDragDropNode();

      }

      $.ajaxSetup({
          beforeSend: function(xhr, settings) {
              if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                  xhr.setRequestHeader("X-CSRFToken", getCsrfToken());
              }
          }
      });

      function csrfSafeMethod(method) {

          return /^(GET|HEAD|OPTIONS|TRACE)$/.test(method);
      }
      function getCsrfToken() {
          return document
            .getElementsByName("csrfmiddlewaretoken")[0]
            .getAttribute("value");
        }
      function updateJson(){
        let posting = $.post("{% url 'update-activity-json' %}", {json: `${JSON.stringify(objectJson)}`});
        posting.done(function(data) {
          console.info(data);
      });
    }

        });
  </script>
</html>
